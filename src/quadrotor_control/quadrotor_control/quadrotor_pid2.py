""" A ROS2 node that implements a PID controller for a quadrotor."""
import rclpy
from rclpy.node import Node

from quadrotor_interfaces.msg import State, RotorCommand

import numpy as np
from scipy.spatial.transform import Rotation
import math

import os
from ament_index_python.packages import get_package_share_directory
import yaml

from typing import Union, List

# For colored traceback
try:
    import IPython.core.ultratb
except ImportError:
    # No IPython. Use default exception printing.
    pass
else:
    import sys
    sys.excepthook = IPython.core.ultratb.ColorTB()

# Constants
DEFAULT_FREQUENCY = 240  # Hz
DEFAULT_QOS_PROFILE = 10
DEFAULT_MAX_ANGLES = math.pi / 8  # radians


class QuadrotorPID(Node):
    """
    A ROS2 node that implements a PID controller for a quadrotor.

    This node subscribes to the current state and reference state of the quadrotor, and publishes the rotor speeds
    required to achieve the desired state. The PID gains and other parameters can be configured via ROS2 parameters.

    The node uses the following conventions for the coordinate frames:
    - The world frame is the inertial frame, with the z-axis pointing upwards.
    - The body frame is attached to the quadrotor, with the x-axis pointing forwards, the y-axis pointing to the right,
        and the z-axis pointing downwards when the quadrotor is level.
    - The reference frame is a frame attached to the world, with the x-axis pointing forwards, the y-axis pointing to
        the right, and the z-axis pointing upwards.

    The node assumes that the quadrotor is a rigid body with a known mass and moment of inertia, and that the rotor
    speeds are proportional to the thrust generated by each rotor.

    Parameters:
        KP_Z (float): The proportional gain for the z-axis (vertical) position controller.
        KD_Z (float): The derivative gain for the z-axis (vertical) position controller.
        KP_XY (float): The proportional gain for the x- and y-axis (horizontal) position controller.
        KD_XY (float): The derivative gain for the x- and y-axis (horizontal) position controller.
        KP_RP (float): The proportional gain for the roll and pitch controllers.
        KD_RP (float): The derivative gain for the roll and pitch controllers.
        KP_Y (float): The proportional gain for the yaw controller.
        KD_Y (float): The derivative gain for the yaw controller.
        MAX_ROLL_PITCH (float): The maximum roll and pitch angles that the quadrotor should achieve, in radians.
        quadrotor_description (str): The name of the quadrotor, used to load the quadrotor's parameters from a config
            file (the file is assumed to be in the quadrotor_description package inside the config folder).
        state_topic (str): The name of the topic where the quadrotor's current state is published.
        reference_topic (str): The name of the topic where the quadrotor's reference state is published.
        rotor_speeds_topic (str): The name of the topic where the desired rotor speeds are published.
        command_publishing_frequency (int): The frequency at which the desired rotor speeds are published, in Hz.

    Subscribers:
        state_topic (State): The current state of the quadrotor.
        reference_topic (State): The desired state of the quadrotor.

    Publishers:
        rotor_speeds_topic (RotorCommand): The desired rotor speeds.

    Timers:
        command_publishing_timer: The timer that controls the publishing frequency of the desired rotor speeds.
    """

    def __init__(self):
        """ Initialize the node's parameters, subscribers, publishers and timers."""
        super().__init__('quadrotor_pid_node')

        # Declare the parameters
        self.declare_parameter('KP_Z', 40.0)  # For thrust
        self.declare_parameter('KD_Z', 5.0)  # For thrust
        self.declare_parameter('KP_XY', 1.0)  # For position
        self.declare_parameter('KD_XY', 40.0)  # For position
        self.declare_parameter('KP_RP', 5.0)  # For roll and pitch
        self.declare_parameter('KD_RP', 1.0)  # For roll and pitch
        self.declare_parameter('KP_Y', 40.0)  # For yaw
        self.declare_parameter('KD_Y', 5.0)  # For yaw
        self.declare_parameter('MAX_ROLL_PITCH', DEFAULT_MAX_ANGLES)  # For roll and pitch
        self.declare_parameter('quadrotor_description', 'cf2x')  # quadrotor name (for config file)
        self.declare_parameter('state_topic', 'quadrotor_state')
        self.declare_parameter('reference_topic', 'quadrotor_reference')
        self.declare_parameter('rotor_speeds_topic', 'quadrotor_rotor_speeds')
        self.declare_parameter('command_publishing_frequency', DEFAULT_FREQUENCY)

        # Get the parameters
        self.KP_Z = self.get_parameter_value('KP_Z', 'float')
        self.KD_Z = self.get_parameter_value('KD_Z', 'float')
        self.KP_XY = self.get_parameter_value('KP_XY', 'float')
        self.KD_XY = self.get_parameter_value('KD_XY', 'float')
        self.KP_RP = self.get_parameter_value('KP_RP', 'float')
        self.KD_RP = self.get_parameter_value('KD_RP', 'float')
        self.KP_Y = self.get_parameter_value('KP_Y', 'float')
        self.KD_Y = self.get_parameter_value('KD_Y', 'float')
        self.MAX_ROLL_PITCH = self.get_parameter_value('MAX_ROLL_PITCH', 'float')
        self.quadrotor_description = self.get_parameter_value('quadrotor_description', 'str')
        self.state_topic = self.get_parameter_value('state_topic', 'str')
        self.reference_topic = self.get_parameter_value('reference_topic', 'str')
        self.rotor_speeds_topic = self.get_parameter_value('rotor_speeds_topic', 'str')
        self.command_publishing_frequency = self.get_parameter_value('command_publishing_frequency', 'int')

        # Subscribers and Publishers
        self.state_subscriber = self.create_subscription(msg_type=State,
                                                         topic=self.state_topic,
                                                         callback=self.receive_state_callback,
                                                         qos_profile=DEFAULT_QOS_PROFILE
                                                         )
        self.reference_subscriber = self.create_subscription(msg_type=State,
                                                             topic=self.reference_topic,
                                                             callback=self.receive_reference_callback,
                                                             qos_profile=DEFAULT_QOS_PROFILE
                                                             )
        self.command_publisher = self.create_publisher(msg_type=RotorCommand,
                                                       topic=self.rotor_speeds_topic,
                                                       qos_profile=DEFAULT_QOS_PROFILE
                                                       )

        # Control the publishing rate
        self.command_publishing_period = 1.0 / self.command_publishing_frequency

        # Initialize the constants,  control errors and published/subscribed data
        self.initialize_constants()
        self.initialize_errors()
        self.initialize_data()

        # Initialize timers
        self.command_publishing_timer = self.create_timer(timer_period_sec=self.command_publishing_period,
                                                          callback=self.publish_command
                                                          )
        # Announce that the node is initialized
        self.start_time = self.get_clock().now()
        self.get_logger().info(f'PID node initialized at {self.start_time.seconds_nanoseconds()}')

    def get_parameter_value(self, parameter_name: str, parameter_type: str) -> Union[bool, int, float, str, List[str]]:
        """
        Get the value of a parameter with the given name and type.

        Args:
            parameter_name (str): The name of the parameter to retrieve.
            parameter_type (str): The type of the parameter to retrieve. Supported types are 'bool', 'int', 'float', 'str',
                'list[float]' and 'list[str]'.

        Returns:
            The value of the parameter, cast to the specified type.

        Raises:
            ValueError: If the specified parameter type is not supported.
        """

        parameter = self.get_parameter(parameter_name)
        parameter_value = parameter.get_parameter_value()

        if parameter_type == 'bool':
            return parameter_value.bool_value
        elif parameter_type == 'int':
            return parameter_value.integer_value
        elif parameter_type == 'float':
            return parameter_value.double_value
        elif parameter_type == 'str':
            return parameter_value.string_value
        elif parameter_type == 'list[str]':
            return parameter_value.string_array_value
        elif parameter_type == 'list[float]':
            return parameter_value.double_array_value
        else:
            raise ValueError(f"Unsupported parameter type: {parameter_type}")

    def initialize_constants(self):
        """
        Initializes the constants used in the quadrotor PID controller.

        Reads the quadrotor parameters from a YAML file located in the quadrotor_description package,
        calculates the maximum thrust, maximum RPM, maximum torque in the XY plane and maximum torque
        around the Z axis, and sets the hover RPM based on the weight of the quadrotor.

        Raises:
            FileNotFoundError: If the configuration file couldn't be found.
            yaml.YAMLError: If the configuration file couldn't be loaded due to a YAML error.
        """

        config_folder = os.path.join(get_package_share_directory('quadrotor_description'), 'config')
        config_file = os.path.join(config_folder, f'{self.quadrotor_description}_params.yaml')
        with open(config_file, 'r') as stream:
            try:
                parameters = yaml.safe_load(stream)
            except yaml.YAMLError as exc:
                self.get_logger().error(
                    f"Cofiguration File {config_file} Couldn't Be Loaded, Raised Error {exc}")
                parameters = dict()
        quadrotor_params = parameters[f'{self.quadrotor_description.upper()}_PARAMS']
        self.G = 9.81
        self.KF = quadrotor_params['KF']
        self.KM = quadrotor_params['KM']
        self.ARM = quadrotor_params['ARM']
        self.M = quadrotor_params['M']
        self.T2W = quadrotor_params['T2W']
        self.W = self.G * self.M
        self.HOVER_RPM = math.sqrt(self.W / (4 * self.KF))
        self.MAX_THRUST = self.T2W * self.W
        self.MAX_RPM = math.sqrt(self.MAX_THRUST / (4 * self.KF))
        self.MAX_TORQUE_XY = self.ARM * self.KF * self.MAX_RPM ** 2
        self.MAX_TORQUE_Z = 2 * self.KM * self.MAX_RPM ** 2

    def initialize_errors(self):
        """ Initializes the control errors including position, rotation, velocity and angular velocity errors.
        TODO: Add integral error
        """
        self.error_p = np.zeros(3)  # position
        self.error_r = np.zeros(3)  # rotation (EULER ANGLES)
        self.error_v = np.zeros(3)  # velocity
        self.error_w = np.zeros(3)  # angular velocity (body frame)
        # TODO add integral error

    def initialize_data(self):
        """ Initializes the actual and reference states and the rotor command. 
        The actual state and reference state corresponde to the State() message type but in a dictionary format.
        """
        self.actual_state = {'position': np.array([0.0, 0.0, 0.0]),
                             'orientation': Rotation.from_euler('xyz', [0.0, 0.0, 0.0]),
                             'velocity': np.array([0.0, 0.0, 0.0]),
                             'angular_velocity': np.array([0.0, 0.0, 0.0])
                             }
        self.reference_state = {'position': np.array([0.0, 0.0, 0.0]),
                                'orientation': Rotation.from_euler('xyz', [0.0, 0.0, 0.0]),
                                'velocity': np.array([0.0, 0.0, 0.0]),
                                'angular_velocity': np.array([0.0, 0.0, 0.0])
                                }
        self.command = RotorCommand()

    def receive_state_callback(self, msg: State):
        """ Convert recieve state msg to the actual state dictionary.

        Args:
            msg (State): The current state of the quadrotor.
        """
        self.actual_state['position'] = np.array([msg.pose.position.x, msg.pose.position.y, msg.pose.position.z])
        self.actual_state['orientation'] = Rotation.from_quat([msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w])
        self.actual_state['velocity'] = np.array([msg.twist.linear.x, msg.twist.linear.y, msg.twist.linear.z])
        self.actual_state['angular_velocity'] = np.array([msg.twist.angular.x, msg.twist.angular.y, msg.twist.angular.z])

    def receive_reference_callback(self, msg: State):
        """ Convert the recieved reference state msg to the reference state dictionary.

        Args:
            msg (State): The desired state of the quadrotor.
        """
        self.reference_state['position'] = np.array([msg.pose.position.x, msg.pose.position.y, msg.pose.position.z])
        self.reference_state['orientation'] = Rotation.from_quat(
            [msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w])
        self.reference_state['velocity'] = np.array([msg.twist.linear.x, msg.twist.linear.y, msg.twist.linear.z])
        self.reference_state['angular_velocity'] = np.array([msg.twist.angular.x, msg.twist.angular.y, msg.twist.angular.z])

    def publish_command(self):
        """ Calculate the desired rotor speeds using P(I)D control and publish the command
        This function is called back by the command_publishing_timer at the frequency specified by the command_publishing_frequency parameter.
        """
        error_p = self.reference_state['position'] - self.actual_state['position']

        error_v = self.reference_state['velocity'] - self.actual_state['velocity']
        KP_XYZ = np.array([self.KP_XY, self.KP_XY, self.KP_Z])
        KD_XYZ = np.array([self.KD_XY, self.KD_XY, self.KD_Z])
        desired_acc = np.multiply(KP_XYZ, error_p) + np.multiply(KD_XYZ, error_v)
        desired_thrust = self.M * (desired_acc[2] + self.G)
        # self.get_logger().info(f'desired_acc: {desired_acc}')
        desired_yaw = self.reference_state['orientation'].as_euler('xyz')[2]
        current_yaw = self.actual_state['orientation'].as_euler('xyz')[2]
        # self.get_logger().info(f'current state: {self.actual_state}')

        desired_roll = (1.0/self.G) * (desired_acc[0] * math.sin(desired_yaw) - desired_acc[1] * math.cos(desired_yaw))
        desired_pitch = (1.0/self.G) * (desired_acc[0] * math.cos(desired_yaw) + desired_acc[1] * math.sin(desired_yaw))
        # self.get_logger().info(f'desired_pitch: {desired_pitch}')
        desired_euler = np.array([desired_roll, desired_pitch, desired_yaw])

        desired_w = np.array([0.0, 0.0, 0.0])

        error_r = desired_euler - self.actual_state['orientation'].as_euler('xyz')
        error_w = desired_w - self.actual_state['angular_velocity']

        KP_RPY = np.array([self.KP_RP, self.KP_RP, self.KP_Y])
        KD_RPY = np.array([self.KD_RP, self.KD_RP, self.KD_Y])
        desired_torques = np.multiply(KP_RPY, error_r) + np.multiply(KD_RPY, error_w)

        # calculate the rotor speeds
        self.command.rotor_speeds = self.calculate_command(desired_thrust, desired_torques)

        # publish the command
        self.command_publisher.publish(self.command)

    def calculate_command(self, thrust: float, torques: np.ndarray) -> np.ndarray:
        """ Claculate the rotor speeds using the thrust and torques. 
        Uses the following equation:
            [thrust, torques] = A * [w1^2, w2^2, w3^2, w4^2]

        Args:
            thrust (float): The desired thrust.
            torques (np.ndarray): The desired torques.

        Returns:
            np.ndarray: The desired rotor speeds.
        """
        # self.get_logger().info(f'{thrust=:.2f} {torques}')
        A = np.array([[self.KF, self.KF, self.KF, self.KF],
                      [0, self.ARM*self.KF, 0, -self.ARM*self.KF],
                      [-self.ARM*self.KF, 0, self.ARM*self.KF, 0],
                      [self.KM, -self.KM, self.KM, -self.KM]])
        arm_angle = math.pi / 4
        A = np.array([[self.KF, self.KF, self.KF, self.KF],
                      self.KF*self.ARM*np.array([math.cos(arm_angle), math.sin(arm_angle), -math.cos(arm_angle), -math.sin(arm_angle)]),
                      self.KF*self.ARM*np.array([-math.sin(arm_angle), math.cos(arm_angle), math.sin(arm_angle), -math.cos(arm_angle)]),
                      [-self.KM, self.KM, -self.KM, self.KM]])

        rotor_speeds_squared = np.matmul(np.linalg.inv(A), np.array([thrust, torques[0], torques[1], torques[2]]))
        rotor_speeds_squared = np.clip(rotor_speeds_squared, 0, self.MAX_RPM**2)
        rotor_speeds = np.sqrt(rotor_speeds_squared)
        actual_thrust = self.KF * np.sum(rotor_speeds_squared)
        actual_torques = np.array([self.ARM * self.KF * (rotor_speeds_squared[0] - rotor_speeds_squared[2]),
                                   self.ARM * self.KF * (rotor_speeds_squared[1] - rotor_speeds_squared[3]),
                                   self.KM * (rotor_speeds_squared[0] - rotor_speeds_squared[1] + rotor_speeds_squared[2] - rotor_speeds_squared[3])])
        rotor_speeds = rotor_speeds.astype(np.float32)
        return rotor_speeds


def main(args=None):
    ''' Main function for the quadrotor PID node.'''
    rclpy.init(args=args)
    node = QuadrotorPID()
    rclpy.spin(node)

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
